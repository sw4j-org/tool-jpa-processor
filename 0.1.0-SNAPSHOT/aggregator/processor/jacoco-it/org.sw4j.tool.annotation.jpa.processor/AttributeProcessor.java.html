<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AttributeProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JPA Annotation Processor (Annotation Processor)</a> &gt; <a href="index.source.html" class="el_package">org.sw4j.tool.annotation.jpa.processor</a> &gt; <span class="el_source">AttributeProcessor.java</span></div><h1>AttributeProcessor.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 uwe
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.sw4j.tool.annotation.jpa.processor;

import java.beans.Introspector;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.annotation.Nonnull;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.persistence.AccessType;
import javax.persistence.Id;
import javax.tools.Diagnostic;
import org.sw4j.tool.annotation.jpa.generator.model.Attribute;
import org.sw4j.tool.annotation.jpa.generator.model.Entity;

/**
 * This is a processor to handle attributes of classes with an @Entity annotation.
 *
 * @author Uwe Plonus
 */
public class AttributeProcessor {

    /** The prefix of a generic property. */
    private static final String PROPERTY_PREFIX = &quot;get&quot;;

    /** The length of the prefix of a generic property. */
<span class="fc" id="L48">    private static final int PROPERTY_PREFIX_LENGTH = &quot;get&quot;.length();</span>

    /** The prefix of a boolean property. */
    private static final String BOOLEAN_PROPERTY_PREFIX = &quot;is&quot;;

    /** The length of the prefix of a boolean property. */
<span class="fc" id="L54">    private static final int BOOLEAN_PROPERTY_PREFIX_LENGTH = &quot;is&quot;.length();</span>

    /** The processing environment used to access the tool facilities. */
    private ProcessingEnvironment processingEnv;

    /**
     * Default constructor for the attribute processor.
     *
     */
<span class="fc" id="L63">    public AttributeProcessor() {</span>
<span class="fc" id="L64">    }</span>

    /**
     * Initializes the processor with the processing environment.
     *
     * @param processingEnv environment to access facilities the tool framework provides to the processor.
     */
    @SuppressWarnings(&quot;checkstyle:HiddenField&quot;)
    public void init(@Nonnull final ProcessingEnvironment processingEnv) {
<span class="fc" id="L73">        this.processingEnv = processingEnv;</span>
<span class="fc" id="L74">    }</span>

    /**
     * Process all possible attributes of an {@code Entity} class.
     *
     * @param entity the entity this attributes belongs to.
     * @param possibleAttributes all enclosed elements of the element that denotes the {@code Entity}.
     */
    public void process(@Nonnull final Entity entity, @Nonnull final List&lt;? extends Element&gt; possibleAttributes) {
<span class="fc" id="L83">        AccessType accessType = null;</span>
<span class="fc" id="L84">        Map&lt;String, Element&gt; possibleFields = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L85">        Map&lt;String, Element&gt; possibleProperties = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L86">        Map&lt;String, Element&gt; possibleIds = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">        for (Element possibleAttribute: possibleAttributes) {</span>
<span class="fc" id="L88">            String attributeName = null;</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">            if (isField(possibleAttribute)) {</span>
<span class="fc" id="L90">                attributeName = possibleAttribute.getSimpleName().toString();</span>
<span class="fc" id="L91">                possibleFields.put(attributeName, possibleAttribute);</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">            } else if (isProperty(possibleAttribute)) {</span>
<span class="fc" id="L93">                attributeName = getAttributeNameFromProperty(possibleAttribute);</span>
<span class="fc" id="L94">                possibleProperties.put(attributeName, possibleAttribute);</span>
            }
<span class="fc bfc" id="L96" title="All 4 branches covered.">            if (attributeName != null &amp;&amp; isPossibleIdAttribute(possibleAttribute)) {</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">                if (possibleIds.put(attributeName, possibleAttribute) != null) {</span>
<span class="nc" id="L98">                    this.processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,</span>
                            new StringBuilder(&quot;The entity \&quot;&quot;)
                                    .append(entity.getName())
                                    .append(&quot;\&quot; (with class name \&quot;&quot;)
                                    .append(entity.getClassName())
                                    .append(&quot;\&quot;) has the same attribute annotated with @Id twice.&quot;));
                }
            }
<span class="fc" id="L106">        }</span>

<span class="fc bfc" id="L108" title="All 2 branches covered.">        if (possibleIds.size() == 1) {</span>
<span class="fc" id="L109">            Map.Entry&lt;String, Element&gt; id = possibleIds.entrySet().iterator().next();</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">            if (isField(id.getValue())) {</span>
<span class="fc" id="L111">                accessType = AccessType.FIELD;</span>
            } else {
<span class="fc" id="L113">                accessType = AccessType.PROPERTY;</span>
            }
<span class="fc bfc" id="L115" title="All 2 branches covered.">            if (accessType == AccessType.FIELD) {</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">                for (Map.Entry&lt;String, Element&gt; possibleField: possibleFields.entrySet()) {</span>
<span class="fc" id="L117">                    processField(entity, possibleField.getValue());</span>
<span class="fc" id="L118">                }</span>
            } else {
<span class="fc bfc" id="L120" title="All 2 branches covered.">                for (Map.Entry&lt;String, Element&gt; possibleProperty: possibleProperties.entrySet()) {</span>
<span class="fc" id="L121">                    processProperty(entity, possibleProperty.getValue());</span>
<span class="fc" id="L122">                }</span>
            }
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        } else if (possibleIds.isEmpty()) {</span>
<span class="fc" id="L125">            this.processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, new StringBuilder(</span>
                    &quot;This annotation processor does not support entities without @Id annotations. The entity \&quot;&quot;)
                    .append(entity.getName())
                    .append(&quot;\&quot; (with class name \&quot;&quot;)
                    .append(entity.getClassName())
                    .append(&quot;\&quot;) has no @Id attributes.&quot;));
        } else {
<span class="nc" id="L132">            this.processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, new StringBuilder(</span>
                    &quot;This annotation processor does not support entities with multiple @Id annotations. The entity \&quot;&quot;)
                    .append(entity.getName())
                    .append(&quot;\&quot; (with class name \&quot;&quot;)
                    .append(entity.getClassName())
                    .append(&quot;\&quot;) has more than 1 @Id attribute.&quot;));
        }
<span class="fc" id="L139">    }</span>

    /**
     * Process a single field attribute.
     *
     * @param entity the entity this attribute belongs to.
     * @param fieldElement the field of the attribute.
     */
    private void processField(@Nonnull final Entity entity, @Nonnull final Element fieldElement) {
<span class="fc" id="L148">        Attribute attribute = new Attribute(fieldElement.getSimpleName().toString(),</span>
                isPossibleIdAttribute(fieldElement), getDataTypeFromType(fieldElement.asType()));
<span class="fc" id="L150">        entity.addAttribute(attribute);</span>
<span class="fc" id="L151">    }</span>

    /**
     * Process a single property attribute.
     *
     * @param entity the entity this attribute belongs to.
     * @param propertyElement the property of the attribute.
     */
    private void processProperty(@Nonnull final Entity entity, @Nonnull final Element propertyElement) {
<span class="fc" id="L160">        TypeMirror returnType = ((ExecutableElement)propertyElement).getReturnType();</span>
<span class="fc" id="L161">        Attribute attribute = new Attribute(getAttributeNameFromProperty(propertyElement),</span>
                isPossibleIdAttribute(propertyElement), getDataTypeFromType(returnType));
<span class="fc" id="L163">        entity.addAttribute(attribute);</span>
<span class="fc" id="L164">    }</span>

    /**
     * Return the datatype as String from the given TypeMirror.
     *
     * @param type the type to convert.
     * @return the datatype of the type.
     */
    private String getDataTypeFromType(TypeMirror type) {
<span class="fc" id="L173">        String dataType = &quot;&quot;;</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (type.getKind().isPrimitive()) {</span>
            // This is a primitive type (e.g. int or float)
<span class="fc" id="L176">            dataType = type.toString();</span>
        } else {
            // The type is either a class or an interface
<span class="fc" id="L179">            Element dataTypeElement = this.processingEnv.getTypeUtils().asElement(type);</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">            if (dataTypeElement != null) {</span>
<span class="fc" id="L181">                ElementKind dataTypeKind = dataTypeElement.getKind();</span>
<span class="pc bpc" id="L182" title="3 of 4 branches missed.">                if (dataTypeKind.isClass() || dataTypeKind.isInterface()) {</span>
<span class="fc" id="L183">                    dataType = ((TypeElement)dataTypeElement).getQualifiedName().toString();</span>
                }
            }
        }
<span class="fc" id="L187">        return dataType;</span>
    }

    /**
     * Test if the given field or property is a possible {@code @Id}.
     *
     * @param element the element to check.
     * @return {@code true} if either the fieldElement or the propertyElement denote an {@code @Id}.
     */
    private boolean isPossibleIdAttribute(@Nonnull final Element element) {
<span class="fc" id="L197">        Id idAnnotation = element.getAnnotation(Id.class);</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        return idAnnotation != null;</span>
    }

    /**
     * Checks if the given element is a field.
     *
     * @param element the element to check.
     * @return {@code true} if the element is a field.
     */
    private boolean isField(@Nonnull final Element element) {
<span class="fc" id="L208">        return ElementKind.FIELD.equals(element.getKind());</span>
    }

    /**
     * Checks if the given element is a property. This method only checks for the getter methods.
     *
     * @param element the element to check.
     * @return {@code true} if the element is the getter of a property.
     */
    private boolean isProperty(@Nonnull final Element element) {
<span class="fc" id="L218">        boolean isProperty = false;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        if (ElementKind.METHOD.equals(element.getKind())) {</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">            isProperty = !&quot;&quot;.equals(getAttributeNameFromProperty(element));</span>
        }
<span class="fc" id="L222">        return isProperty;</span>
    }

    /**
     * Returns the attribute name from the method name of the element. This method assumes that the given element is a
     * method. If the method is not a valid property (by either starting with &quot;get&quot; or by starting with &quot;is&quot; and being
     * a boolean property) then an empty string is returned.
     *
     * @param element the element to check.
     * @return either the property name or an empty string.
     */
    private String getAttributeNameFromProperty(@Nonnull final Element element) {
<span class="fc" id="L234">        StringBuilder result = new StringBuilder();</span>
<span class="fc" id="L235">        String elementName = element.getSimpleName().toString();</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (elementName.startsWith(PROPERTY_PREFIX)) {</span>
<span class="fc" id="L237">            result.append(Introspector.decapitalize(elementName.substring(PROPERTY_PREFIX_LENGTH)));</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">        } else if (elementName.startsWith(BOOLEAN_PROPERTY_PREFIX)) {</span>
<span class="fc" id="L239">            TypeMirror returnType = ((ExecutableElement)element).getReturnType();</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">            if (TypeKind.BOOLEAN.equals(returnType.getKind())) {</span>
<span class="fc" id="L241">                result.append(Introspector.decapitalize(elementName.substring(BOOLEAN_PROPERTY_PREFIX_LENGTH)));</span>
            } else {
<span class="fc" id="L243">                Element returnElement = this.processingEnv.getTypeUtils().asElement(returnType);</span>
<span class="pc bpc" id="L244" title="1 of 4 branches missed.">                if (returnElement != null &amp;&amp; ElementKind.CLASS.equals(returnElement.getKind())) {</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">                    if (Boolean.class.getName().equals(((TypeElement)returnElement).getQualifiedName().toString())) {</span>
<span class="fc" id="L246">                        result.append(Introspector.decapitalize(elementName.substring(2)));</span>
                    }
                }
            }
        }
<span class="fc" id="L251">        return result.toString();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>